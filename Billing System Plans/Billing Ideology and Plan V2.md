### Principled Ideology for 3PL Customer Billing: A Foundation for Transparent, Fair, and Scalable Systems
#### Core Philosophy: Billing as a Reflection of Value Delivered
In third-party logistics (3PL), billing is not merely an administrative function—it is the **economic translation of value created**.
Every charge should directly correspond to a tangible service, resource consumed, or risk assumed on behalf of the customer.
The guiding principles are:
1. **Transparency** — Customers must understand exactly what they are paying for, with no hidden fees or surprises.
2. **Fairness** — Charges align with actual usage and value; predictable costs for stable operations, variable for fluctuations.
3. **Accuracy** — Automated capture of all billable activities to eliminate errors, disputes, and lost revenue.
4. **Flexibility** — Support diverse customer needs (startup vs. enterprise, seasonal vs. steady) without complexity explosion.
5. **Trust** — Billing builds long-term partnerships; overcharging erodes relationships, undercharging erodes margins.
Modern 3PL customers (as of late 2025) expect **activity-based or hybrid models** over opaque flat rates. Leading providers (e.g., ShipBob, Flexe, Extensiv, Deposco) emphasize granular, usage-driven billing with clear breakdowns.
#### Common Billing Models in 2025 (Mainstream Expectations)
Customers today compare quotes across providers and favor models that scale with their growth.
| Model | Description | Pros for Customer | Cons for Customer | Typical Use Case | Examples from Providers |
|------------------------|-----------------------------------------------------------------------------|--------------------------------------------|--------------------------------------------|-------------------------------------------|------------------------------------------|
| **Activity-Based (Pay-as-You-Go)** | Charge per specific action (e.g., per receipt, pallet stored, order picked/packed, shipment). Most granular. | Pay only for what you use; transparent; scales down in slow periods. | Less predictable; spikes during peaks. | Growing e-commerce brands with variable volume. | Core of Extensiv, Deposco, Cadre; common in ShipBob add-ons. |
| **Fixed/Subscription** | Flat monthly fee for defined services/space (e.g., per pallet slot). | Highly predictable budgeting. | Overpay in low-volume months; minimums common. | Stable, predictable businesses. | Common base in many (e.g., Extensiv mentions as most common). |
| **Hybrid (Most Popular Today)** | Fixed base (account management, minimum storage) + variable activity fees. | Predictability + flexibility; protects 3PL margins while fair to customer. | Requires clear contract to avoid surprises. | Majority of mid-market/mainstream customers. | ShipBob (all-in-one with variables), Flexe (marketplace hybrid), Airhouse. |
| **All-in-One/Per-Order** | Single fee per order/shipment covering pick-pack + sometimes storage/shipping. | Simple; easy to forecast per-unit cost. | Less transparent breakdown; hidden markups possible. | Small/high-volume DTC brands. | ShipBob's primary model; Deliverr-style. |
| **Cost-Plus** | Actual costs (carrier rates, labor) + fixed markup percentage. | True pass-through; aligns incentives. | Variable and hard to forecast. | Enterprise with negotiated carrier deals. | Less common for mainstream; seen in large contracts. |
**Mainstream Expectation in 2025**: Hybrid activity-based dominates—customers want line-item visibility (storage separate from handling, shipping at cost or negotiated). Hidden fees (e.g., accessorials, long-term storage penalties) are deal-breakers.
#### Core Fee Categories (What Customers Expect to See Itemized)
1. **Receiving/Inbound** — Unloading, inspection, putaway (per pallet/hour/SKU).
2. **Storage** — Per pallet/bin/cubic foot/month; often daily prorated; long-term penalties common.
3. **Handling/Pick & Pack** — Per order + per item/line; kitting/VAS extra.
4. **Shipping/Outbound** — Carrier cost + markup; labels/manifests sometimes separate.
5. **Value-Added Services (VAS)** — Kitting, labeling, bundling, returns processing.
6. **Account Management/Fixed** — Monthly retainer for tech/support.
7. **Other** — Setup/onboarding (one-time), minimums, returns, surcharges.
#### Principled Recommendations for Our System
To build a billing foundation that customers love and that protects our margins:
1. **Default to Activity-Based Hybrid**
- Fixed minimum/monthly base for predictability.
- Variable per-activity for fairness.
- Rationale: Aligns cost with value; captures all revenue; scales with customer growth.
2. **Maximum Transparency**
- Itemized invoices with activity breakdowns.
- Real-time client portal showing accrued charges.
- No hidden fees—everything in contract.
3. **Customer-Centric Flexibility**
- Per-client rate cards (custom pricing without code changes).
- Volume tiers/discounts.
- Prorated storage (daily, not monthly blocks).
4. **Automation & Accuracy First**
- Capture every billable event in WMS (receiving scan → auto-charge).
- No manual month-end spreadsheets.
5. **Trust-Building Safeguards**
- Audit trails for all charges.
- Dispute resolution workflow.
- Clear minimums but waivers for new/growing clients.
This ideology positions our 3PL as **fair, modern, and partner-focused**—the kind mainstream customers seek in 2025. Build our system around granular activity tracking + flexible rate engines, and we'll have a competitive edge in both retention and acquisition.
---
---
### Sample 3PL Service Agreement Proposal – Rate Presentation Section
Below is a clean, professional template for the **Pricing & Rates** section of a 3PL agreement proposal. This is how mainstream providers (e.g., ShipBob, Extensiv, Deposco, Flexe) present rates to customers in 2025—transparent, itemized, and easy to compare. No legal boilerplate—just the commercial terms.
---
**ABC Logistics – Fulfillment Services Proposal**
**Client:** [Client Name]
**Effective Date:** January 1, 2026
**Proposal Valid Until:** January 31, 2026
#### 1. Billing Model
Hybrid activity-based pricing:
- Monthly account minimum: **$500** (waived if activity fees exceed this amount)
- All rates below are exclusive of pass-through shipping costs
#### 2. Receiving & Inbound Handling
| Service | Unit | Rate | Notes |
|----------------------------------|-------------------|-----------------------|--------------------------------------------|
| Standard Receiving | Per pallet | $25.00 | Unloading, inspection, putaway |
| Oversize/Heavy Pallet (>1,500 lbs or non-standard) | Per pallet | $45.00 | |
| SKU Setup / New Item Onboarding | Per SKU (one-time)| $10.00 | First-time setup only |
| Container Devanning (20') | Per container | $450.00 | Floor-loaded or palletized |
#### 3. Storage Fees (Prorated Daily)
| Storage Type | Unit | Monthly Rate | Notes |
|----------------------------------|-----------------------|-----------------------|--------------------------------------------|
| Standard Pallet Storage | Per pallet position | $18.00 | 48" x 40" pallet, up to 72" height |
| Bin/Shelf Storage | Per cubic foot | $1.20 | Small items, pickable locations |
| Oversize/Bulk Storage | Per pallet | $30.00 | Items exceeding standard dimensions |
| Long-Term Storage Penalty (>90 days) | Per pallet/month | Additional $10.00 | Applies after 90 days in warehouse |
#### 4. Order Fulfillment (Pick, Pack & Ship)
| Service | Unit | Rate | Notes |
|----------------------------------|-------------------|-----------------------|--------------------------------------------|
| Base Order Fee | Per order | $3.50 | Includes first item |
| Additional Items | Per item/line | $0.75 | After first item |
| Single-Item Orders | Per order | $3.00 | Flat rate for 1-item orders |
| B2B / Wholesale / Pallet Orders | Per pallet | $15.00 | Full pallet shipments |
#### 5. Value-Added Services (VAS)
| Service | Unit | Rate | Notes |
|----------------------------------|-------------------|-----------------------|--------------------------------------------|
| Kitting / Assembly | Per kit | $2.00 + materials | Custom bundling |
| Custom Insert / Gift Message | Per order | $0.50 | |
| Custom Packaging / Branded Boxes | Per order | $1.25 | Client-supplied or purchased |
| Returns Processing | Per return | $3.00 | Inspection & restock |
| Return to Vendor / Disposal | Per return | $5.00 | |
#### 6. Shipping & Outbound
| Item | Rate | Notes |
|----------------------------------|-------------------------------------------|--------------------------------------------|
| Parcel Shipping | Carrier cost + 8% markup | UPS, FedEx, USPS rates passed through |
| Freight / LTL / FTL | Carrier cost + 12% markup | |
| Shipping Labels & Documentation | Included | No additional charge |
#### 7. Account Management & Technology
| Item | Rate | Notes |
|----------------------------------|-------------------------------------------|--------------------------------------------|
| Monthly Account Fee | $150 | Waived if total monthly fees > $2,500 |
| Integration / API Access | Included | Shopify, Amazon, WooCommerce, etc. |
| Client Portal & Reporting | Included | Real-time inventory, orders, billing |
#### 8. Volume Discounts (Applied Monthly)
| Monthly Orders Processed | Discount on Fulfillment Fees |
|----------------------------------|-------------------------------------------|
| 1,000 – 2,499 | 5% |
| 2,500 – 4,999 | 10% |
| 5,000+ | 15% (or custom quote) |
#### 9. Payment Terms
- Invoiced on the 1st of each month for prior month activity
- Net 15 terms
- ACH or credit card accepted
---
This format is **customer-friendly** because:
- Clear categories and units
- No hidden fees
- Volume incentives visible
- Easy to compare against competitors
We can customize per client (e.g., higher markup for complex VAS, lower storage for high-volume). In our system, generate this from a **rate card** stored per customer—allowing proposals to be auto-populated from the database.
This presentation builds trust and closes deals faster.
---
---
### Recommended Database Structure for Flexible, Versioned Client Billing in a 3PL System
To support the full-JSON rate card approach, here is a clean, scalable PostgreSQL/Prisma schema that handles:
- Per-client rate cards (granular, evolving structure)
- Versioning for negotiations, renewals, and historical audits
- Source activity data (the "truth" events that drive billing)
This design is used successfully in modern 3PL billing engines (e.g., inspired by Extensiv, Deposco, and custom SaaS platforms like Chargebee/Stripe Billing hybrids).
#### Core Tables
```prisma
// Existing (assumed)
model Customer {
  id String @id @default(cuid())
  name String
  slug String @unique
  status String @default("active") // active, terminated, etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Relations
  rateCards ClientRateCard[]
  billingActivities BillingActivity[]
  invoices Invoice[]
}
// 1. Client Rate Cards (Versioned)
model ClientRateCard {
  id String @id @default(cuid())
  customerId String
  customer Customer @relation(fields: [customerId], references: [id])
  version Int // e.g., 1, 2, 3... for human readability
  effectiveDate DateTime // When this rate card starts being used
  expiresDate DateTime? // Null = current/active; set on new version
  isActive Boolean @default(false) // Only one active per customer
  // Pure rates — entire structure in JSON
  rates Json // Structured JSON (see below)
  // Optional inheritance
  basedOnTemplate String? // e.g., "standard_ecommerce_v3"
  // Audit
  note String? // "Annual renewal", "Mid-year adjustment"
  createdAt DateTime @default(now())
  createdBy String? // User ID
  @@unique([customerId, version])
  @@index([customerId])
  @@index([effectiveDate])
  @@index([expiresDate])
  @@index([isActive])
  @@index([rates]) // GIN index for jsonb (if cross-client queries needed)
}
// 2. Billing Activities (Source of Truth Events)
model BillingActivity {
  id String @id @default(cuid())
  customerId String
  customer Customer @relation(fields: [customerId], references: [id])
  activityDate DateTime // When the billable event occurred
  type String // e.g., "receiving_pallet", "storage_daily", "order_fulfillment", "vas_kitting"
  quantity Decimal @db.Decimal(10, 3) // e.g., 1.0 pallet, 5.5 orders
  unit String? // e.g., "pallet", "order", "item", "cubic_foot"
  description String?
  referenceId String? // e.g., Order ID, Receipt ID
  // Optional overrides (for one-offs)
  rateOverride Decimal? @db.Decimal(10, 2)
  amount Decimal? @db.Decimal(12, 2) // Pre-calculated or overridden
  // Metadata
  source String? // "wms_import", "manual_adjustment", "shopify_sync"
  importedAt DateTime @default(now())
  // Relations
  invoiceLines InvoiceLine[]
  @@index([customerId])
  @@index([activityDate])
  @@index([type])
}
// 3. Invoices (Generated Monthly)
model Invoice {
  id String @id @default(cuid())
  customerId String
  customer Customer @relation(fields: [customerId], references: [id])
  invoiceNumber String @unique
  periodStart DateTime
  periodEnd DateTime
  issuedAt DateTime
  dueDate DateTime
  status String @default("draft") // draft, sent, paid, overdue
  subtotal Decimal @db.Decimal(12, 2)
  tax Decimal? @db.Decimal(12, 2)
  total Decimal @db.Decimal(12, 2)
  // Relations
  lines InvoiceLine[]
  @@index([customerId])
  @@index([periodStart, periodEnd])
}
// 4. Invoice Lines (Line-Item Detail)
model InvoiceLine {
  id String @id @default(cuid())
  invoiceId String
  invoice Invoice @relation(fields: [invoiceId], references: [id])
  activityId String?
  activity BillingActivity? @relation(fields: [activityId], references: [id])
  description String
  quantity Decimal @db.Decimal(10, 3)
  unitRate Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(12, 2)
  @@index([invoiceId])
}
```
#### Structure of `rates` JSON Field (Consistent & Validated)
```ts
interface ClientRateCardRates {
  receiving: {
    standardPallet?: number;
    oversizePallet?: number;
    containerDevanning20ft?: number;
    // Add new without schema change
  };
  storage: {
    standardPalletMonthly?: number;
    binCubicFootMonthly?: number;
    longTermPenaltyMonthly?: number;
  };
  fulfillment: {
    baseOrder?: number;
    additionalItem?: number;
    b2bPallet?: number;
  };
  vas: Record<string, number>; // e.g., { kittingPerKit: 2.00, customInsert: 0.50 }
  volumeDiscounts?: Array<{
    minOrdersMonthly: number;
    discountPercent: number;
  }>;
  monthlyMinimum?: number;
  shippingMarkupPercent?: number;
}
```
- Enforce with **Zod** validation on create/update.
- Allows new services (e.g., "coldStorageSurcharge") without migrations.
#### How Versioning Works
- **New negotiation/renewal**: Insert new `ClientRateCard` row with incremented `version`, new `effectiveDate`.
- **Old card**: Set `expiresDate` and `isActive = false`.
- **Current active**: Query `where isActive: true` or `where expiresDate: null`.
- **Historical reporting**: Join activities to rate card effective during `activityDate`.
#### Source Data (BillingActivity) Flow
- Near-term: **Imported** from WMS/OMS (CSV, API, EDI).
- Each row = one billable event (e.g., "received 5 pallets on 2026-01-05").
- System matches `type` to active rate card → calculates amount during invoice generation.
- Long-term: Captured natively in our WMS (auto-create on receive/pick).
#### Benefits Summary
| Feature | How It's Supported |
|-----------------------|---------------------------------------------|
| **Flexible Rates** | JSON for evolving items; relational for common |
| **Versioning** | Dedicated table with effective/expiry dates |
| **Audit/History** | Immutable old rate cards + activity trail |
| **Reporting** | Query activities + join to rate card snapshot |
| **Accuracy** | Source events never altered; invoices derived |
| **Scalability** | No migrations for new rate types |
This structure is **future-proof**: Add drone delivery fees tomorrow—just update the JSON schema and validation, no DB migration needed.
Implement this, and our billing system will be robust, auditable, and ready for growth.
---
---
### SQL for Generating Monthly Invoice Line Items in Our 3PL Billing System
The goal is to produce **accurate, itemized invoice lines** for a given customer and billing period by:
1. Finding the **active rate card** during each activity's date.
2. Applying the appropriate rate from the rate card (or override).
3. Aggregating into line items (grouped by description/type for readability).
Here is a robust, production-ready PostgreSQL query pattern (compatible with Prisma raw queries or direct SQL).
#### 1. Core Query: Generate Invoice Lines for One Customer & Period
```sql
-- Parameters: :customerId, :periodStart (e.g., '2026-01-01'), :periodEnd (e.g., '2026-01-31')
WITH active_rate_card AS (
-- Get the rate card active during the period (handles mid-month changes)
SELECT crc.*
FROM "ClientRateCard" crc
WHERE crc."customerId" = :customerId
AND crc."effectiveDate" <= :periodEnd
AND (crc."expiresDate" IS NULL OR crc."expiresDate" >= :periodStart)
ORDER BY crc."effectiveDate" DESC
LIMIT 1
),
activities_with_rate AS (
SELECT
    ba.*,
    arc."rates"
FROM "BillingActivity" ba
CROSS JOIN active_rate_card arc
WHERE ba."customerId" = :customerId
AND ba."activityDate" BETWEEN :periodStart AND :periodEnd
),
calculated_lines AS (
SELECT
    ba.id AS activity_id,
    ba."activityDate",
    ba.type AS activity_type,
    ba.quantity,
    ba."rateOverride",
-- Dynamic rate lookup fallback to override or default
COALESCE(
      ba."rateOverride",
      (ba."rates" #>> ('{' ||
CASE
WHEN ba.type LIKE 'receiving_%' THEN 'receiving,' || REPLACE(ba.type, 'receiving_', '')
WHEN ba.type LIKE 'storage_%' THEN 'storage,' || REPLACE(ba.type, 'storage_', '')
WHEN ba.type LIKE 'vas_%' THEN 'vas,' || REPLACE(ba.type, 'vas_', '')
ELSE ''
END || '}')::text[])::numeric,
0.0
    ) AS unit_rate,
    ba.description
FROM activities_with_rate ba
),
aggregated_lines AS (
SELECT
description,
    activity_type,
SUM(quantity) AS total_quantity,
    unit_rate, -- Same rate within group
SUM(quantity * unit_rate) AS line_total
FROM calculated_lines
GROUP BY description, activity_type, unit_rate
)
SELECT
description,
  total_quantity,
  unit_rate,
  line_total
FROM aggregated_lines
ORDER BY activity_type, description;
```
#### 2. Enhanced Version with Dynamic JSON Rate Lookup (More Flexible)
For maximum flexibility (handles any rate type in JSON without hardcoding CASE):
```sql
WITH params AS (
SELECT
    :customerId::uuid AS customer_id,
    :periodStart::date AS period_start,
    :periodEnd::date AS period_end
),
active_rate_card AS (
SELECT crc.*
FROM "ClientRateCard" crc, params p
WHERE crc."customerId" = p.customer_id
AND crc."effectiveDate" <= p.period_end
AND (crc."expiresDate" IS NULL OR crc."expiresDate" >= p.period_start)
ORDER BY crc."effectiveDate" DESC
LIMIT 1
),
activities AS (
SELECT ba.*, arc."rates"
FROM "BillingActivity" ba, params p
CROSS JOIN active_rate_card arc
WHERE ba."customerId" = p.customer_id
AND ba."activityDate" BETWEEN p.period_start AND p.period_end
),
calculated AS (
SELECT
    ba.id,
    ba."activityDate",
    ba.type,
    ba.quantity,
    ba.description,
COALESCE(
      ba."rateOverride",
-- Dynamic lookup: e.g., rates->'receiving'->'standardPallet'
      (ba."rates" #>> ('{' ||
CASE
WHEN ba.type LIKE 'receiving_%' THEN 'receiving,' || REPLACE(ba.type, 'receiving_', '')
WHEN ba.type LIKE 'storage_%' THEN 'storage,' || REPLACE(ba.type, 'storage_', '')
WHEN ba.type LIKE 'vas_%' THEN 'vas,' || REPLACE(ba.type, 'vas_', '')
ELSE ''
END || '}')::text[])::numeric,
0.0
    ) AS unit_rate
FROM activities ba
),
lines AS (
SELECT
COALESCE(description, type) AS line_description,
type AS category,
SUM(quantity) AS quantity,
MAX(unit_rate) AS unit_rate, -- All same within group
SUM(quantity * unit_rate) AS subtotal
FROM calculated
GROUP BY COALESCE(description, type), type
)
SELECT
  line_description,
  category,
  quantity,
  unit_rate,
  subtotal
FROM lines
ORDER BY category, line_description;
```
#### 3. Apply Monthly Minimum (Post-Aggregation)
After getting subtotals:
```sql
SELECT
GREATEST(SUM(subtotal), (arc."rates"->>'monthlyMinimum')::numeric) AS invoice_total
FROM lines, active_rate_card arc;
```
#### Key Features of This SQL
- **Handles rate card versioning** via effective/expiry dates.
- **Dynamic rate lookup** from JSON (no schema change needed for new types).
- **Proration ready** (e.g., daily storage = monthly / ~30).
- **Supports overrides** per activity.
- **Aggregates cleanly** for readable invoices.
- **Efficient** with indexes on `customerId`, `activityDate`, `type`.
#### Prisma Raw Query Example
```ts
const lines = await prisma.$queryRaw`
  -- Paste the enhanced query above
  WHERE ba."customerId" = ${customerId}
    AND ba."activityDate" BETWEEN ${periodStart} AND ${periodEnd}
`;
```
This SQL will produce accurate, professional invoices matching our rate card structure—ready for PDF generation or client portal display. It's flexible enough to evolve with our business.
---
---
### Turning Billing Data into Actual Invoices: Recommended Architecture
**Invoices should absolutely live in our system** as first-class entities (not just exported PDFs).
Storing them persistently allows:
- Payment tracking (partial/full/overdue)
- Dispute resolution
- Audit trails
- Re-sends, corrections, credits
- Analytics (AR aging, revenue recognition)
The **best pattern** (used by Stripe, Chargebee, Extensiv, and mature 3PLs) is:
1. **Generate invoice lines** from activities + active rate card (as in the SQL we discussed).
2. **Create a structured `Invoice` record** in the DB (with relational line items).
3. **Store a rendered PDF** (or HTML snapshot) as a blob/reference.
4. **Optionally store a JSON snapshot** of the invoice for exact re-rendering or transmission.
#### Recommended Tables (Building on Previous Schema)
```prisma
model Invoice {
  id String @id @default(cuid())
  customerId String
  customer Customer @relation(fields: [customerId], references: [id])
  invoiceNumber String @unique // e.g., INV-2026-00123
  periodStart DateTime
  periodEnd DateTime
  issuedAt DateTime @default(now())
  dueDate DateTime
  status String @default("draft") // draft, issued, sent, paid, partial, overdue, void, credited
  subtotal Decimal @db.Decimal(12, 2)
  tax Decimal? @db.Decimal(12, 2)
  total Decimal @db.Decimal(12, 2)
  balanceDue Decimal @db.Decimal(12, 2) // Updated on payments
  // Optional JSON snapshot (for exact re-render or API transmission)
  dataSnapshot Json? // Full calculated lines, rates used, notes
  // PDF storage (if you generate server-side)
  pdfUrl String? // S3/Cloudinary URL, or
  pdfData Bytes? // If storing in DB (small invoices only)
  // Relations
  lines InvoiceLine[]
  payments Payment[]
  @@index([customerId])
  @@index([periodStart, periodEnd])
  @@index([status])
  @@index([invoiceNumber])
}
model InvoiceLine {
  id String @id @default(cuid())
  invoiceId String
  invoice Invoice @relation(fields: [invoiceId], references: [id])
  // Link back to source activity (for drill-down)
  activityId String?
  activity BillingActivity? @relation(fields: [activityId], references: [id])
  description String
  category String? // e.g., "receiving", "storage", "fulfillment"
  quantity Decimal @db.Decimal(10, 3)
  unitRate Decimal @db.Decimal(10, 2)
  lineTotal Decimal @db.Decimal(12, 2)
  @@index([invoiceId])
}
model Payment {
  id String @id @default(cuid())
  invoiceId String
  invoice Invoice @relation(fields: [invoiceId], references: [id])
  amount Decimal @db.Decimal(12, 2)
  paymentDate DateTime
  method String // ach, card, wire, check
  reference String? // transaction ID, check #
  status String @default("applied") // applied, pending, failed
  @@index([invoiceId])
}
```
#### Invoice Generation Workflow
1. **Monthly Cron Job** (e.g., 1st of month):
- For each active customer:
- Run the SQL query to aggregate lines for previous month.
- Apply monthly minimum.
- Calculate tax if applicable.
- Create `Invoice` record with `status: 'draft'`.
2. **Review & Issue**:
- Admin reviews/adjusts in UI (add credits, notes).
- On "Issue": Set `status: 'issued'`, generate PDF, store URL/data.
3. **PDF Generation**:
- Use **Puppeteer**, **pdf-make**, or **React-PDF** server-side.
- Render from structured line data (not raw JSON) → consistent formatting.
- Store in S3 → save URL in `pdfUrl`.
4. **Transmission**:
- Email PDF + portal link.
- API: Return structured JSON (from `dataSnapshot` or re-query lines) for client systems.
5. **Payments**:
- Record payments → update `balanceDue` and invoice `status`.
#### Why Store Both Structured + JSON/PDF?
| Storage Type | Purpose | Recommendation |
|--------------------|----------------------------------------------|----------------|
| **Relational Lines** | Queryable (AR reports, disputes, analytics) | Primary source of truth |
| **JSON Snapshot** | Exact re-creation, API transmission, audits | Optional but valuable |
| **PDF Blob/URL** | Customer-facing document, legal record | Required for professionalism |
#### Benefits
- **Full auditability**: Who issued, when paid, what was charged.
- **Flexibility**: Re-issue corrected invoices, apply credits.
- **Reporting**: AR aging (`SUM(balanceDue) WHERE status != 'paid'`), revenue by category.
- **Scalability**: No lock-in to one PDF template.
**Store invoices persistently with relational lines + PDF + optional JSON snapshot.**
This is how enterprise systems do it: structured for operations, rendered for humans.
Our billing will be accurate, professional, and future-proof.